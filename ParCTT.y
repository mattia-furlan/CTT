-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParCTT
  ( happyError
  , myLexer
  , pProgram
  , pToplevel
  , pTerm
  ) where

import Prelude

import qualified CoreCTT
import LexCTT

}

%name pProgram Program
%name pTerm Term
%name pToplevel Toplevel
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '->' { PT _ (TS _ 3) }
  '0' { PT _ (TS _ 4) }
  ':' { PT _ (TS _ 5) }
  ';' { PT _ (TS _ 6) }
  '=' { PT _ (TS _ 7) }
  'N' { PT _ (TS _ 8) }
  'S' { PT _ (TS _ 9) }
  'U' { PT _ (TS _ 10) }
  '[' { PT _ (TS _ 11) }
  ']' { PT _ (TS _ 12) }
  'ind' { PT _ (TS _ 13) }
  L_Ident  { PT _ (TV $$) }

%%

Ident :: { CoreCTT.Ident }
Ident  : L_Ident { CoreCTT.Ident $1 }

Program :: { CoreCTT.Program }
Program : ListToplevel { CoreCTT.Program $1 }

Term :: { CoreCTT.Term }
Term : Term1 { $1 }
     | Term1 '->' Term { CoreCTT.Abst (CoreCTT.Ident "") $1 $3 }
     | '[' Ident ':' Term ']' Term { CoreCTT.Abst $2 $4 $6 }

Term1 :: { CoreCTT.Term }
Term1 : Term2 { $1 }
      | Term1 Term2 { CoreCTT.App $1 $2 }

Term2 :: { CoreCTT.Term }
Term2 : Term3 { $1 }
      | Ident { CoreCTT.Var $1 }
      | 'U' { CoreCTT.Universe }
      | 'N' { CoreCTT.Nat }
      | '0' { CoreCTT.Zero }
      | 'S' Term2 { CoreCTT.Succ $2 }
      | 'ind' Term2 Term2 Term2 Term2 { CoreCTT.Ind $2 $3 $4 $5 }

Term3 :: { CoreCTT.Term }
Term3 : '(' Term ')' { $2 }

Toplevel :: { CoreCTT.Toplevel }
Toplevel : Ident ':' Term '=' Term { CoreCTT.Definition $1 $3 $5 }
         | Term { CoreCTT.Example $1 }

ListToplevel :: { [CoreCTT.Toplevel] }
ListToplevel : {- empty -} { [] }
             | Toplevel ';' ListToplevel { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}